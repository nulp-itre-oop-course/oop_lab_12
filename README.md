# Конструювання класів з використанням віртуальних функцій
**Мета**: створити, відлагодити та протестувати програму, у якій створити базовий та похідні класи з використанням віртуальних функцій для обробки даних.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ з базовим (батьківським), похідними (дочірніми) класами та віртуальними функціями для обробки даних, також реалізувати відповідні конструктори, деструктори, методи. Використайте динамічний масив (вектор) структур для зберігання введених даних.  Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio  Code  з описом кожного класу у відповідних парах 
заголовного та виконуваного файлів.
1. Ознайомитися із властивостями віртуальних функцій. Обдумати способи їх використання для створення програм.
2. Вибрати завдання згідно свого варіанту у ДОДАТКУ.
3. Розробити блок-схему алгоритму програми.
4. Реалізувати програму для вводу і виводу даних полів (членів) структур вкладених у клас.

### Короткі відомості
Віртуальна функція в мові С++ — це особливий тип функції, яка, при її виклику, виконує «найдочірніший» метод, який існує між батьківським і дочірніми класами. Ця властивість відома як поліморфізм. Дочірній метод викликається тоді, коли збігається сигнатура (ім’я, типи параметрів і чи є метод константним) і тип повернення дочірнього методу з сигнатурою і типом повернення методу батьківського класу. Такі методи називаються перевизначеннями (або “перевизначеними методами”). Сигнатура віртуального методу дочірнього класу повинна повністю відповідати сигнатурі віртуального методу батьківського класу. Якщо у дочірнього методу буде  інший тип параметрів, ніж у батьківського, то викликатися цей метод не буде.
Якщо функція позначена як віртуальна, то всі відповідні перевизначення теж вважаються віртуальними, навіть якщо біля них явно не вказано ключове слова `virtual`. Однак, наявність ключового слова `virtual` біля методів дочірніх класів послужить корисним нагадуванням про те, що ці методи є віртуальними, а не звичайними. Отже, хорошою практикою є вказування ключового слова `virtual` біля перевизначень в дочірніх класах, навіть якщо це не є строго необхідним. Щоб зробити функцію віртуальною, потрібно просто вказати 
ключове слово `virtual` перед оголошенням функції. Наприклад:
```c++
#include <iostream>
 
class Parent
{
public:
    virtual const char* getName() { return "Parent"; } // 
додали ключове слово virtual
};
class Child: public Parent
{
public:
    virtual const char* getName() { return "Child"; }
};
int main()
{
    Child child;
    Parent &rParent = child;
    std::cout << "rParent is a " << rParent.getName() << '\n';
    return 0;
}
```
Результат:
```
rParent is a Child
```
Оскільки `rParent` є посиланням на батьківську частину об’єкту `child`, то, звичайно, при обробці `rParent.getName()` викликався б `Parent::getName()`. Проте, оскільки `Parent::getName()` є віртуальною функцією, то компілятор розуміє, що потрібно подивитися, чи є перевизначення цього методу в дочірніх класах. І компілятор знаходить `Child::getName()`!
Розглянемо наступний приклад:
```c++
#include <iostream>
 
class A
{
public:
    virtual const char* getName() { return "A"; }
};
 
class B: public A
{
public:
    virtual const char* getName() { return "B"; }
};
 
class C: public B
{
public:
    virtual const char* getName() { return "C"; }
};
 
class D: public C
{
public:
    virtual const char* getName() { return "D"; }
};
int main()
{
    C c;
    A &rParent = c;
    std::cout << "rParent is a " << rParent.getName() << '\n';
 
    return 0;
}
```
Спочатку створюється об’єкт `c` класу `C`. `rParent` — це посилання класу `A`, якому ми вказуємо посилатися на частину `A` об’єкту `c`. Потім викликається метод `rParent.getName()`. Виклик `rParent.GetName()` призводить до виклику `A::getName()`. Однак, оскільки   `A::getName()` є віртуальною функцією, то компілятор шукає «найдочірніший» метод між `A` і `C`. У цьому випадку — це `C::getName()`.
Зверніть увагу, компілятор не викликатиме  `D::getName()`, оскільки наш вихідний об’єкт був класу `C`, а не класу `D`, тому розглядаються методи тільки між класами `A` і `C`.
Результат виконання програми:
```
rParent is a C
```
Не викликайте віртуальні функції в тілі конструкторів або деструкторів. Пам’ятайте, що при створенні об’єкта класу `Child` спочатку   створюється батьківська частина цього об’єкту, а потім вже дочірня! Якщо ви викликатимете віртуальну функцію з конструктора класу `Parent` при тому, що дочірня частина створюваного об’єкта ще не була створена, то викликати дочірній метод замість батьківського буде неможливо, тому що об’єкт `child` для роботи з методом класу `Child` ще не буде створений. У таких випадках в мові C++ викликатиметься батьківська версія методу. Аналогічна проблема існує і з деструкторами. Якщо ви викликаєте віртуальну функцію в тілі деструктора класу `Parent`, то завжди викликатиметься метод класу `Parent`, тому що дочірня частина об’єкту вже буде знищена.
Недоліком віртуальних функцій є те , що обробка і виконання виклику віртуального методу займає більше часу, ніж обробка і виконання виклику звичайного методу. Крім того, компілятор також повинен виділяти один додатковий вказівник для кожного об’єкта класу, який має одну або кілька віртуальних функцій.
Розглянемо складнійший випадок із батьківським класом `Animal`, додавши тестовий код, зробивши метод `speak()` віртуальним:
```c++
#include <iostream>
#include <string>
 
class Animal
{
protected:
    std::string m_name;
 
    /* Ми робимо цей конструктор protected, тому що не хочемо, щоб користувачі мали можливість створювати об'єкти класу Animal     напряму, але хочемо, щоб в дочірніх класах доступ був відкритий */
    Animal(std::string name)
        : m_name(name)
    {
    }
 
public:
    std::string getName() { return m_name; }
    virtual const char* speak() { return "???"; }
};
 
class Cat: public Animal
{
public:
    Cat(std::string name)
        : Animal(name)
    {
    }
 
    virtual const char* speak() { return "Meow"; }
};
class Dog: public Animal
{
public:
    Dog(std::string name)
        : Animal(name)
    {
    }
 
    virtual const char* speak() { return "Woof"; }
};
 
void report(Animal &animal)
{
    std::cout << animal.getName() << " says " << 
animal.speak() << '\n';
}
 
int main()
{
    Cat cat("Matros");
    Dog dog("Barsik");
 
    report(cat);
    report(dog);
}
```
Результат виконання програми:
```
Matros says Meow
Barsik says Woof
```
При обробці `animal.speak()`, компілятор бачить, що метод `Animal::speak()` є віртуальною функцією. Коли `animal` посилається на частину Animal об’єкту `cat`, то компілятор переглядає всі класи між `Animal` і `Cat`, щоб знайти найбільш дочірній метод `speak()`. І знаходить  `Cat::speak()`. У випадку, коли `animal` посилається на частину `Animal` об’єкту `dog`, компілятор знаходить `Dog::speak()`. Зверніть увагу, ми не зробили `Animal::GetName()` віртуальною функцією. Це через те, що `GetName()` ніколи не перевизначається ні в одному з дочірніх класів, тому в цьому немає необхідності.

## ДОДАТОК

### Варіанти завдань

|  № |       Батьківський клас       |                   Дочірні класи                  |
|----|-------------------------------|--------------------------------------------------|
|  1 | Джерело живлення              | Павербанк, бензиновий/дизель генератор           |
|  2 | Сенсор                        | Датчик температури, датчик світла                |
|  3 | Прилад                        | Мультиметр, осцилограф                           |
|  4 | Провідник сигналів            | Коаксіальний кабель, оптоволокно                 |
|  5 | Радіостанція                  | Базова станція, портативна рація                 |
|  6 | Мікросхема                    | Логічна мікросхема, пам’ять                      |
|  7 | Фільтр                        | Фільтр нижніх частот, смуговий фільтр            |
|  8 | Транзистор                    | Біполярний транзистор, польовий транзистор       |
|  9 | Напівпровідниковий діод       | Стабілітрон, тунельний діод                      |
| 10 | Комунікаційний пристрій       | Маршрутизатор, комутатор                         |
| 11 | Канал передавання даних       | Радіоканал, оптоволоконний канал                 |
| 12 | Двигун                        | Серводвигун, кроковий двигун                     |
| 13 | Зчитувач інформації           | Сканер штрих-коду, RFID-зчитувач                 |
| 14 | Електронна плата              | Макетна плата, друкована плата                   |
| 15 | Контролер                     | Мікроконтролер, програмований логічний контролер |
| 16 | Акумулятор                    | Літій-іонний, свинцево-кислотний                 |
| 17 | Антена                        | Всеспрямована антена, антена направленої дії     |
| 18 | Електромагнітний випромінювач | Світлодіод, лазер                                |
| 19 | Оптичний компонент            | Світлодіод, фоторезистор                         |
| 20 | Звуковий пристрій             | Мікрофон, динамік                                |
| 21 | Дисплей                       | Рідкокристалічний дисплей, OLED-дисплей          |
| 22 | Бездротова технологія         | WiFi, Bluetooth                                  |
| 23 | Операційна система            | Android, iOS                                     |
| 24 | Резонатор                     | Кварцовий резонатор, керамічний резонатор        |
| 25 | Супутниковий термінал         | Термінал для зв’язку, термінал для телебачення   |
| 26 | Датчик руху                   | Інфрачервоний датчик, радарний датчик            |
| 27 | Перетворювач напруги          | Підсилювач напруги, послаблювач напруги          |
| 28 | Реле                          | Електромагнітне реле, твердотільне реле          |
| 29 | Мобільний телефон             | Кнопковий телефон, смартфон                      |
| 30 | Електронний компонент         | Пасивний компонент, активний компонент           |
